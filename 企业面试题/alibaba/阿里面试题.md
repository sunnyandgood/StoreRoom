# 一面
## 内推一面
### 1、自我介绍、项目

### 2、Linux查看CPU命令，常用命令
- 监控CPU的性能一般包括以下3点：运行队列、CPU使用率和上下文切换。
	- 1)`#top -bn 1 -i -c` ：在第三行有显示CPU当前的使用情况。
	- 2)`#vmstat 1 5`
	- 3)`#sar -u 1 5` ：sar命令语法和vmstat一样。命令不存在时需要安装sysstat包
	- 4)`#mpstat 1 5` ： 这个命令也在sysstat包中，语法类似。例如每1秒收集一次，共5次。
	- 5)`#iostat -c 1 2` ：查看io使用情况，也可以来查看cpu
	- 6)`#dstat -c` ：每秒cpu使用率情况获取
- 常用命令:cd切换目录，mkdir创建文件夹，ls查看目录下内容，rm删除，mv修改，vi编辑，chmod修改权限，cp复制，sl跑火车，

### 3、Linux程序如何调试
- 基本调试，获得关键变量 - print 语句
- 获取有关文件系统支持，可用内存，CPU，运行程序的内核状态等信息 - 查询 /proc 文件系统
- 最初的问题诊断，系统调用或库调用的相关问题，了解程序流程 – strace / ltrace
- 应用程序内存空间的问题 – valgrind
- 检查应用程序运行时的行为，分析应用程序崩溃 – gdb

### 4、Top K

https://mp.weixin.qq.com/s/FFsvWXiaZK96PtUg-mmtEw

问题描述：

从arr[1, n]这n个数中，找出最大的k个数，这就是经典的TopK问题。

1)全局排序

​       排序是最容易想到的方法，将n个数排序之后，取出最大的k个，即为所得。


伪代码：

sort(arr, 1, n);


return arr[1, k];

时间复杂度：O(n*lg(n))      (O的发音bigO)

分析：明明只需要TopK，却将全局都排序了，这也是这个方法复杂度非常高的原因。那能不能不全局排序，而只局部排序呢？这就引出了第二个优化方法。

不再全局排序，只对最大的k个排序。

2)局部排序

冒泡是一个很常见的排序方法，每冒一个泡，找出最大值，冒k个泡，就得到TopK。

伪代码：

for(i=1 to k){

​         bubble_find_max(arr,i);

}

return arr[1, k];

时间复杂度：O(n*k)

分析：冒泡，将全局排序优化为了局部排序，非TopK的元素是不需要排序的，节省了计算资源。不少朋友会想到，需求是TopK，是不是这最大的k个元素也不需要排序呢？这就引出了第三个优化方法。

3)堆

思路：只找到TopK，不排序TopK。

先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。

接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。直到，扫描完所有n-k个元素，最终堆中的k个元素，就是猥琐求的TopK。

伪代码：

heap[k] = make_heap(arr[1, k]);

for(i=k+1 to n){

​         adjust_heap(heep[k],arr[i]);

}

return heap[k];

时间复杂度：O(n*lg(k))

画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即lg(k)，故整体时间复杂度是n*lg(k)。

分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？



### 5、数组乱序
- 方法一：（最优解）
  - 新建一个数组，每次从已知数组随机一个数 并把这个数复制到新数组中，
  - 然后将数组的最后一个值 赋值给前面随机到的数的位置上，然后将长度-1，
  - 再从原数组下标-1的数组中随机。 
  - 运算次数就是数组长度，这种方法真的很聪明啊，以下是代码：

  ```java
  import java.util.Arrays;
  import java.util.Random;
  
  /**
   * @Author: 王仁洪
   * @Date: 2019/4/18 11:31
   */
  public class ArrayDisorder {
      public static void main(String[] args) {
          int[] arr = {1,2,3,4,5,6,7,8,9};
          ArrayDisorder array = new ArrayDisorder();
          int[] ints = array.arrayDisorder(arr);
          System.out.println(Arrays.toString(ints));
      }
      public int[] arrayDisorder(int[] arr){
          int arrLength = arr.length;
          int[] newArr = new int[arrLength];
          int length = arrLength + 1;//arr长度减一后的长度
          int newArrIndex = 0;//新数组下标
          Random random = new Random();
          do {
              length = length - 1;
              int index = random.nextInt(length);
              newArr[newArrIndex++] = arr[index];
              arr[index] = arr[length-1];
          }while (length > 1);//count < arrLength
          return newArr;
      }
  }
  ```
































