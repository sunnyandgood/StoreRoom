<div align=center><h1>阿里巴巴电话面试</h1></div>

### 一、10个台阶，每次只能上1个或者2个，一共有多少种走法

#### 第一种，递归思路。

* 如果你上10个台阶，可以分解成下面两种情况：

	* 上9个台阶，最后上1个台阶。假设这种情况下，上前面9个台阶的方法数为m。

	* 上8个台阶，最后上2个台阶。假设这种情况下，上前面8个台阶的方法数为n。

* 所以，上10个台阶的方法数，其实就是 m + n。

* 可以递归为:

  ```java
  f(n) = f(n - 1) + f(n - 2),   n > 2
  f(n) = 2                  ,   n = 2
  f(n) = 1                  ,   n = 1

  private static int step(int n) {
     if (n == 1) return 1;
     if (n == 2) return 2;
     else return step(n - 1) + step(n - 2);
  }
  ```


#### 第二种，排列思路。

10个台阶，全部都走两步的话，无非就是5个两步。

* 全是一步，10个一步。1种。
* 1个两步，8个一步。相当于从9个坑里放1个两步。9C1 = 9种。
* 2个两步，6个一步。相当于从8个坑里放2个两步。8C2 = 28种。
* 3个两步，4个一步。相当于从7个坑里放3个两步。7C3 = 35种。
* 4个两步，2个一步。相当于从6个坑里放4个两步。6C4 = 15种。
* 5个两步。1种。

所以一共有：1 + 9 + 28 + 35 + 15 + 1 = 89种。

### 二、volatile关键字
* volatile关键字强制从公共堆栈获取变量值，而不是从线程私有数据栈获取数据。
* volatile不会发生堵塞；
* 是线程同步的轻量级实现，性能比synchronized强；
* volatile实现线程间数据的可见性，但不能保证原子性。

### 三、三个线程轮流执行顺序打印ABC，依次是ABCABCABC......
- 方法一：最优
  ```java
  package com.edu.thread;
  
  import java.util.concurrent.locks.Condition;
  import java.util.concurrent.locks.ReentrantLock;
  
  /**
   * @Author: 王仁洪
   * @Date: 2019/4/18 9:26
   */
  public class ThreadPrintABC {
      volatile private static char nextPrintWho = 'A';
      private static ReentrantLock lock = new ReentrantLock();
      final private static Condition CONDITIONA = lock.newCondition();
      final private static Condition CONDITIONB = lock.newCondition();
      final private static Condition CONDITIONC = lock.newCondition();
      public static void main(String[] args) {
          Thread threadA = new Thread(){
              @Override
              public void run() {
                  try {
                      lock.lock();
                      while (nextPrintWho != 'A'){
                          CONDITIONA.await();
                      }
                      System.out.print("A");
                      nextPrintWho = 'B';
                      CONDITIONB.signalAll();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }finally {
                      lock.unlock();
                  }
              }
          };
  
          Thread threadB = new Thread(){
              @Override
              public void run() {
                  try {
                      lock.lock();
                      while (nextPrintWho != 'B'){
                          CONDITIONB.await();
                      }
                      System.out.print("B");
                      nextPrintWho = 'C';
                      CONDITIONC.signalAll();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }finally {
                      lock.unlock();
                  }
              }
          };
  
          Thread threadC = new Thread(){
              @Override
              public void run() {
                  try {
                      lock.lock();
                      while (nextPrintWho != 'C'){
                          CONDITIONC.await();
                      }
                      System.out.print("C");
                      nextPrintWho = 'A';
                      CONDITIONA.signalAll();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }finally {
                      lock.unlock();
                  }
              }
          };
  
          Thread[] a = new Thread[5];
          Thread[] b = new Thread[5];
          Thread[] c = new Thread[5];
          for (int i=0;i<5;i++){
              a[i] = new Thread(threadA);
              b[i] = new Thread(threadB);
              c[i] = new Thread(threadC);
              a[i].start();
              b[i].start();
              c[i].start();
          }
      }
  }
  ```
- 方法二：不建议使用  
  ```java
  package com.edu.thread;
  
  /**
   * @Author: 王仁洪
   * @Date: 2019/4/18 11:11
   */
  public class TwoLockPrinter implements Runnable {
      // 打印次数
      private static final int PRINT_COUNT = 10;
      // 前一个线程的打印锁
      private final Object fontLock;
      // 本线程的打印锁
      private final Object thisLock;
      // 打印字符
      private final char printChar;
  
      public TwoLockPrinter(Object fontLock, Object thisLock, char printChar) {
          this.fontLock = fontLock;
          this.thisLock = thisLock;
          this.printChar = printChar;
      }
  
      @Override
      public void run() {
          // 连续打印PRINT_COUNT次
          for (int i = 0; i < PRINT_COUNT; i++) {
              // 获取前一个线程的打印锁
              synchronized (fontLock) {
                  // 获取本线程的打印锁
                  synchronized (thisLock) {
                      //打印字符
                      System.out.print(printChar);
                      // 通过本线程的打印锁唤醒后面的线程
                      // notify和notifyall均可,因为同一时刻只有一个线程在等待
                      thisLock.notify();
                  }
                  // 不是最后一次则通过fontLock等待被唤醒
                  // 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁
                  if(i < PRINT_COUNT - 1){
                      try {
                          // 通过fontLock等待被唤醒
                          fontLock.wait();
  
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                  }
              }
          }
      }
  
      public static void main(String[] args) throws InterruptedException {
          // 打印A线程的锁
          Object lockA = new Object();
          // 打印B线程的锁
          Object lockB = new Object();
          // 打印C线程的锁
          Object lockC = new Object();
  
          // 打印a的线程
          Thread threadA = new Thread(new TwoLockPrinter(lockC, lockA, 'A'));
          // 打印b的线程
          Thread threadB = new Thread(new TwoLockPrinter(lockA, lockB, 'B'));
          // 打印c的线程
          Thread threadC = new Thread(new TwoLockPrinter(lockB, lockC, 'C'));
  
          // 依次开启a b c线程
          threadA.start();
          Thread.sleep(100); // 确保按顺序A、B、C执行
          threadB.start();
          Thread.sleep(100);
          threadC.start();
          Thread.sleep(100);
      }
  }
  ```