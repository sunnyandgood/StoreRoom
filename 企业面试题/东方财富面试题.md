# 壹——JAVA知识
## 一、JAVA基础









## 二、异常



## 三、集合





## 四、多线程
### 1、不同子进程共享同一个父进程的什么资源？
- 子进程将获得父进程数据空间、堆、栈等资源的副本。



## 五、JAVA虚拟机




## 六、内部类


## 七、代码分析



# 贰——设计模式





# 叁——计算机网络
### 1、TCP协议和UDP协议的区别？
- TCP面向连接，UDP面向非连接；
- TCP是可靠传输,UDP是不可靠传输;
- TCP传输速度慢，UDP传输速度快；
- TCP传输数据有序,UDP不保证数据的有序性;
- TCP不保存数据边界,UDP保留数据边界;
- TCP有流量控制和拥塞控制,UDP没有;
- TCP保证数据正确性，UDP可能丢包；
- TCP是重量级协议,UDP是轻量级协议;
- TCP首部较长20字节,UDP首部较短８字节;




# 肆——Web





# 伍——框架



# 陆——数据库
### 1、根据以表格，以学号为主键，在数据库中创建表student
```sql
create table STUDENT{
  STU_NO char(20) NOT NULL PRIMARY KEY,
  STU_NAME char(20),
  STU_SEX char(1) default NULL,
  STU_AGE int,
  STU_SERI char(20)
}
```














# 柒——数据结构
### 1、堆和栈的区别？
- 栈：栈顶的地址和栈的最大容量是系统预先规定好的能从栈获得的空间较小；由系统自动分配，速度较快，但程序员是无法控制的。
- 堆：用户申请，并指明大小；堆获得的空间比较灵活，也比较大；是由new分配的内存，一般速度比较慢，而且容易产生内存碎片。

### 2、一棵完全二叉树中有65个节点，则该二叉树的深度为6
<div align="center"><img src="./img/001.png"/></div>

### 3、一个像素为1024*768的图片在没有压缩的情况下，占用多少存储空间？
```java
1024X768 = 786432像素
786432X2 = 1572864字节
1572864除以1024 = 1536K
1536除以1024 = 1.5M
```

### 4、快速排序的思想是递归，但是它的平均速率确实是众多排序算法中最快的，为什么？

- 用递归能解决的问题通常能将问题不断缩小为性质相同但规模更小的问题，直到问题足够小能够直接解决，而且递归程序看起来非常简洁，是一种非常好的手段；
- 但一般情况下会产出很多无用的东西，衡量好再用递归。


# 捌——算法
### 1.顺时针打印矩阵
- 题目描述：
  - 有一个n * n 的二阶数组，从右上角开始，顺时针，从外到内，依次遍历所有元素。
    ```java
    例如：
      1   2   3   4
      5   6   7   8
      9   10  11  12
      13  14  15  16
    输出：4 8 12 16 15 14 13 9 5 1 2 3 7 11 10 6
    ```
  - 代码实现：
    ```java
    public class Matrix {
          public static void main(String[] args){
              int[][] arr={
                      {1,2,3,4},
                      {5,6,7,8},
                      {9,10,11,12},
                      {13,14,15,16}
              };
              print(arr,4);
          }
          static void print(int[][] arr,int n){
              //先输出最右一列
              for(int i=0;i<n;i++){
                  System.out.print(arr[i][n-1]+" ");
              }
              //输出最下面一行
              for(int i=n-2;i>=0;i--){
                  System.out.print(arr[n-1][i]+" ");   
              }
              //输出最左一列
              for (int i=n-2;i>=0;i--){
                  System.out.print(arr[i][0]+" ");
              }
              //输出第一行
              for (int i=1;i<n-1;i++){
                  System.out.print(arr[0][i]+" ");
              }
              //关键，向左上平移剩余的元素,以[0][0]为起点
              for(int i=0;i<n-2;i++){
                  for(int j=0;j<n-2;j++){
                      arr[i][j]=arr[i+1][j+1];
                  }
              }
              //递归调用
              if(n>1)
                  print(arr,n-2);
          }
      }
    ```

### 2、写一个函数实现对已从小到大排序的数组执行二分法查找
```java
public int binarySearch(int[] arr,int num){
    int index = -1;
    int start = 0;
    int end = arr.length-1;
    int mid;
    while (start<=end){
        mid = (start + end)/2;
        if (arr[mid]==num){
            index = mid;
            break;
        }
        if (arr[mid]<num)
            start = mid + 1;
        if (arr[mid]>num)
            end = mid - 1;
    }
    return index;
}
```

### 3、五猴子分桃问题
- 问题描述：

  - 海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？ 
- 解题：
  ```java
  如果多给4个桃子，则5只猴子每次都可以平均分且无剩余。
  设多给4个后共有A个桃。
  第一只取走后剩下：A×4/5；
  第二只取走后剩下：A×4/5×4/5；
  第三只取走后剩下：A×4/5×4/5×4/5；
  第四只取走后剩下：A×4/5×4/5×4/5×4/5：
  第五只取走后剩下：A×4/5×4/5×4/5×4/5×4/5 = A×1024/3125
  因为A×1024/3125一定是整数，所以A最少是3125。
  所以原来的桃子最少有：3125-4=3121(个)
  ```
- 程序分析：
	- 五只猴子分了五次桃子，
	- 假设第一只猴子那份桃子的个数为x，桃子的总数：`x*5+1`，第一只猴子拿走一份，丢掉一个后还剩下4份。
	- 假设第二只猴子那份桃子的个数为y，第二次分桃子的总数：`4*x=y*5+1` 在此基础上再分5份，拿走一份，丢掉一个还剩四份。
	- 第三只猴子那份桃子也是在第二只猴子剩下的四分里面再分，到第四只，第五只猴子也是。
	- 如果知道了第一只猴子拿走那份桃子的个数x便可以知道所有桃子的总数。
	- x可以由第二只猴子那份桃子`y*5+1/4=x`,y可以从第三只猴子那里求出,第四次猴子求出第三只猴子桃子的个数，第五只猴子求出第四只猴子拿走桃子的个数。
	- 可以假设第一只猴子那份桃子为1开始计算，不满足继续增加，一直到满足为止。
- 程序代码:
  - 方法一：暴力法 
      ```java
      public int monkeyPeach(int monkeyNum){
              //int q = 0;
          int allPeach = monkeyNum * 2;//桃子总数
          while (true) {
             int flag = 0;
              allPeach++;
              int surplus = allPeach;//剩余桃子总数
              for (int j=1;j<=monkeyNum;j++){//有monkeyNu个猴子需要分桃
                  //猴子能够将剩余桃子扔一个，然后平分为monkeyNum份，再拿走自己的那份
                  if ((surplus-1)%monkeyNum==0){
                      surplus = (surplus-1)/monkeyNum * (monkeyNum-1);
                      flag++;
                  }
                      //q++;
              }
              if (flag==monkeyNum){
                  break;
              }
          }
              //System.out.println(q);
          return allPeach;
      }
      ```
  - 方法二：
      ```java
      public int monkey1(int monkeyNum) {
          int allPeach = 1;    // 桃子总数
          int surplus = 1;   //剩下的桃子数
          int count = 0;  // 可以分的猴子数
          //int q = 0;
          while(true){
              //q++;
              if((surplus - 1) % monkeyNum == 0){    // 可以再分一个猴子
                  ++count;
                  surplus = (surplus - 1) / monkeyNum * (monkeyNum-1);
              }else if(count != monkeyNum){    // 不可以再分猴子了
                  surplus = ++allPeach;
                  count = 0;
              }
              if(count == monkeyNum) {    // 满足猴子总数， okay， 找到了
                  //System.out.println(q);
                  return allPeach;
              }
          }
      }
      ```
  - 方法三：返回一个区间内的所有可能
      ```java
      public List<Integer> monkey2(int monkeyNum, int max) {
          List<Integer> list = new ArrayList<>();
          int allPeach = 1;    // 桃子总数
          int surplus = 1;   //剩下的桃子数
          int count = 0;  // 可以分的猴子数
          count = 0;
          while(true){
              if((surplus - 1) % monkeyNum == 0){    // 可以再分一个猴子
                  ++count;
                  surplus = (surplus - 1) / monkeyNum * (monkeyNum-1);
              }else if(count != monkeyNum){    // 不可以再分猴子了
                  surplus = ++allPeach;
                  count = 0;
              }
              if(count == monkeyNum){    // 满足猴子总数， okay， 找到了
                  list.add(allPeach);
                  surplus = ++allPeach;
                  count = 0;
              }
              if(allPeach > max)
                  return list;
          }
      }
      ```
  - 方法四：
      ```java
      public int monkeyPeach(int monkeyNum) {
          //int q = 0;
          int lastPart = 1;   //最后那只猴子拿到的那份桃子数，
          int onePart = 0;    //通过最后那份桃子推理出第一份的桃子数，
          int count = 1;      //循环的次数，设置为条件。一共要循环monkeyNum-1次
          while (count < monkeyNum) {
              onePart = lastPart;
              for (int i = 0; i < monkeyNum-1; i++) {
                  int allPeach = onePart * monkeyNum + 1; //假设第i次桃子的总数 ,从第五次开始
                  //如果不能整除monkeyNum-1就不能推理出上次桃子的分数，叠加桃子数重新开始循环
                  if(allPeach%(monkeyNum-1)!=0){ 
                      lastPart++;
                      //q++;
                      count = 1; //循环计数器次数重置为1
                       break;
                  }
                  onePart = allPeach / 4; //可以求出上次桃子的个数
                  count++; //叠加计数器
              }
          }
          //System.out.println(q);
          return onePart * monkeyNum + 1;
      }
      ```

### 4、去除多个字符串中相同的字符串。
- 例如：
  ```java
  abcded sdfef abcded sdjfk cnjdn sdjfk
  输出的结果
  abcded sdfef sdjfk cnjdn
  ```
- 代码实现  
	- 方法一：暴力实现
      ```java
      public String[] delete(String[] strArr){
          String[] arr = new String[strArr.length];
          for (int i=0;i<strArr.length;i++){
              arr[i] = null;
          }
          int index = 0;
          boolean flag;
          for (int i=0;i<strArr.length;i++){
              flag = false;
              for (int j=0;j<strArr.length;j++){
                  if (null!=arr[j] && arr[j].equals(strArr[i])){
                      flag = true;
                      break;
                  }
              }
              if (!flag){
                  arr[index++] = strArr[i];
              }
          }
          String[] returnArr = new String[index];
          for (int i=0;i<index;i++){
              returnArr[i] = arr[i];
          }
          return returnArr;
      }
      ```
	- 方法二：用List实现
      ```java
      public List<String> deleteSame(String[] strArr){
          List<String> list = new ArrayList<>();
          list.add(strArr[0]);
          for (int i=1;i<strArr.length;i++){
              if (!list.contains(strArr[i])){
                  list.add(strArr[i]);
              }
          }
          return list;
      }
      ````
  
### 5、算法：给出start和end两个数据，随机产生100个不重复的数据。举例说明：1-100
```java
public int[] erandomDistinct(int start,int end,int vector){
    Random random = new Random();
    int[] arr = new int[end-start+1];
    int[] newArr = new int[vector];
    int flag = 0;
    for (int i=start;i<=end;i++){
        arr[flag++] = i;
    }
    flag = vector+1;
    for (int i=0;i<vector;i++){
        flag--;
        int index  = random.nextInt(flag);
        System.out.println(Arrays.toString(arr)+"======="+index);
        newArr[i] = arr[index];
        arr[index] = arr[flag-1];
    }
    return newArr;
}
```



















# 玖——逻辑
### 1.10个台阶，每次只能上1个或者2个，一共有多少种走法
- 第一种，递归思路。
    - 如果你上10个台阶，可以分解成下面两种情况：

      - 上9个台阶，最后上1个台阶。假设这种情况下，上前面9个台阶的方法数为m。
      - 上8个台阶，最后上2个台阶。假设这种情况下，上前面8个台阶的方法数为n。

    - 所以，上10个台阶的方法数，其实就是 m + n。

    - 可以递归为:

      ```java
      f(n) = f(n - 1) + f(n - 2),   n > 2
      f(n) = 2                  ,   n = 2
      f(n) = 1                  ,   n = 1

      private static int step(int n) {
         if (n == 1) return 1;
         if (n == 2) return 2;
         else return step(n - 1) + step(n - 2);
      }
      ```

- 第二种，排列思路。
    - 0个两步，10个一步。相对于全是一步。10C0 = 1种。
    - 1个两步，8个一步。相当于从9个坑里放1个两步。9C1 = 9种。
    - 2个两步，6个一步。相当于从8个坑里放2个两步。8C2 = 28种。
    - 3个两步，4个一步。相当于从7个坑里放3个两步。7C3 = 35种。
    - 4个两步，2个一步。相当于从6个坑里放4个两步。6C4 = 15种。
    - 5个两步，0个一步。相当于全是两步。5C5 = 1种。
- 所以一共有：1 + 9 + 28 + 35 + 15 + 1 = 89种。

### 2、给定两个排好序的数组，怎样高效得判断这两个数组中存在相同的数字？
- 方法一：时间复杂度（O(nlogn)）
  - 任意挑选一个数组，遍历这个数组的所有元素，遍历过程中，在另一个数组中对第一个数组中的每个元素进行binary search。
      ```java
      boolean findcommon(int a[],int b[]) {
          int i;
          for(i=0;i<a.length;i++) {
              int start = 0;
              int end = b.length-1;
              int mid;
              while(start<=end) {
                  mid = (start+end)/2;
                  if(a[i] == b[mid])
                      return true;
                  else if (a[i]<b[mid])
                      end = mid-1;
                  else
                      start = mid+1;
              }
          }
          return false;
      }
      ```
- 方法二：时间复杂度（O(n)）
    - 首先设两个下标，分别初始化为两个数组的起始地址，依次向前推进。
    - **推进的规则**：是比较两个数组中的数字，**小的那个数组的下标向前推进一步**，直到任何一个数组的下标到达数组末尾时，如果这时还没碰到相同的数字，说明数组中没有相同的数字。

      ```java
      public boolean findcommo(int a[], int b[]) {
          int i = 0;
          int j = 0;
          while (i < a.length && j < b.length) {
              if (a[i] == b[j])
                  return true;
              if (a[i] > b[j])
                  j++;
              if (a[i] < b[j])
                  i++;
          }
          return false;
      }
      ```


# 拾——操作系统
### 1、轮询任务调度和可抢占任务调度有什么区别？
- 轮询调度的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。只有在当前任务主动放弃CPU控制权的情况下（比如任务挂起），才允许其他任务（包括高优先级的任务）控制CPU。开始循环。
- 抢占式调度允许高优先级的任务打断当前执行的任务，抢占CPU的控制权。这有利于后面的高优先级的任务也能及时得到响应。但实现相对较复杂且可能出现低优先级的任务长期得不到调度。
