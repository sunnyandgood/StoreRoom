# 壹——JAVA知识
## 一、JAVA基础









## 二、异常



## 三、集合





## 四、多线程




## 五、JAVA虚拟机




## 六、内部类


## 七、代码分析



# 贰——设计模式





# 叁——计算机网络
### 1、TCP协议和UDP协议的区别？
- TCP面向连接，UDP面向非连接；
- TCP是可靠传输,UDP是不可靠传输;
- TCP传输速度慢，UDP传输速度快；
- TCP传输数据有序,UDP不保证数据的有序性;
- TCP不保存数据边界,UDP保留数据边界;
- TCP有流量控制和拥塞控制,UDP没有;
- TCP保证数据正确性，UDP可能丢包；
- TCP是重量级协议,UDP是轻量级协议;
- TCP首部较长20字节,UDP首部较短８字节;




# 肆——Web





# 伍——框架



# 陆——数据库
















# 柒——数据结构
### 1、堆和栈的区别？
- 栈：栈顶的地址和栈的最大容量是系统预先规定好的能从栈获得的空间较小；由系统自动分配，速度较快，但程序员是无法控制的。
- 堆：用户申请，并指明大小；堆获得的空间比较灵活，也比较大；是由new分配的内存，一般速度比较慢，而且容易产生内存碎片。

### 2、一棵完全二叉树中有65个节点，则该二叉树的深度为6
<div align="center"><img src="./img/001.png"/></div>

# 捌——算法
### 1.顺时针打印矩阵
- 题目描述：
  - 有一个n * n 的二阶数组，从右上角开始，顺时针，从外到内，依次遍历所有元素。
    ```java
    例如：
      1   2   3   4
      5   6   7   8
      9   10  11  12
      13  14  15  16
    输出：4 8 12 16 15 14 13 9 5 1 2 3 7 11 10 6
    ```
  - 代码实现：
    ```java
    public class Matrix {
          public static void main(String[] args){
              int[][] arr={
                      {1,2,3,4},
                      {5,6,7,8},
                      {9,10,11,12},
                      {13,14,15,16}
              };
              print(arr,4);
          }
          static void print(int[][] arr,int n){
              //先输出最右一列
              for(int i=0;i<n;i++){
                  System.out.print(arr[i][n-1]+" ");
              }
              //输出最下面一行
              for(int i=n-2;i>=0;i--){
                  System.out.print(arr[n-1][i]+" ");   
              }
              //输出最左一列
              for (int i=n-2;i>=0;i--){
                  System.out.print(arr[i][0]+" ");
              }
              //输出第一行
              for (int i=1;i<n-1;i++){
                  System.out.print(arr[0][i]+" ");
              }
              //关键，向左上平移剩余的元素,以[0][0]为起点
              for(int i=0;i<n-2;i++){
                  for(int j=0;j<n-2;j++){
                      arr[i][j]=arr[i+1][j+1];
                  }
              }
              //递归调用
              if(n>1)
                  print(arr,n-2);
          }
      }
    ```

# 玖——逻辑
### 1.10个台阶，每次只能上1个或者2个，一共有多少种走法
- 第一种，递归思路。
    - 如果你上10个台阶，可以分解成下面两种情况：

      - 上9个台阶，最后上1个台阶。假设这种情况下，上前面9个台阶的方法数为m。
      - 上8个台阶，最后上2个台阶。假设这种情况下，上前面8个台阶的方法数为n。

    - 所以，上10个台阶的方法数，其实就是 m + n。

    - 可以递归为:

      ```java
      f(n) = f(n - 1) + f(n - 2),   n > 2
      f(n) = 2                  ,   n = 2
      f(n) = 1                  ,   n = 1

      private static int step(int n) {
         if (n == 1) return 1;
         if (n == 2) return 2;
         else return step(n - 1) + step(n - 2);
      }
      ```

- 第二种，排列思路。
    - 0个两步，10个一步。相对于全是一步。10C0 = 1种。
    - 1个两步，8个一步。相当于从9个坑里放1个两步。9C1 = 9种。
    - 2个两步，6个一步。相当于从8个坑里放2个两步。8C2 = 28种。
    - 3个两步，4个一步。相当于从7个坑里放3个两步。7C3 = 35种。
    - 4个两步，2个一步。相当于从6个坑里放4个两步。6C4 = 15种。
    - 5个两步，0个一步。相当于全是两步。5C5 = 1种。
- 所以一共有：1 + 9 + 28 + 35 + 15 + 1 = 89种。

### 2、给定两个排好序的数组，怎样高效得判断这两个数组中存在相同的数字？
- 方法一：时间复杂度（O(nlogn)）
  - 任意挑选一个数组，遍历这个数组的所有元素，遍历过程中，在另一个数组中对第一个数组中的每个元素进行binary search。
      ```java
      boolean findcommon(int a[],int b[]) {
          int i;
          for(i=0;i<a.length;i++) {
              int start = 0;
              int end = b.length-1;
              int mid;
              while(start<=end) {
                  mid = (start+end)/2;
                  if(a[i] == b[mid])
                      return true;
                  else if (a[i]<b[mid])
                      end = mid-1;
                  else
                      start = mid+1;
              }
          }
          return false;
      }
      ```
- 方法二：时间复杂度（O(n)）
    - 首先设两个下标，分别初始化为两个数组的起始地址，依次向前推进。
    - **推进的规则**：是比较两个数组中的数字，**小的那个数组的下标向前推进一步**，直到任何一个数组的下标到达数组末尾时，如果这时还没碰到相同的数字，说明数组中没有相同的数字。

      ```java
      public boolean findcommo(int a[], int b[]) {
          int i = 0;
          int j = 0;
          while (i < a.length && j < b.length) {
              if (a[i] == b[j])
                  return true;
              if (a[i] > b[j])
                  j++;
              if (a[i] < b[j])
                  i++;
          }
          return false;
      }
      ```


# 拾——操作系统
### 1、轮询任务调度和可抢占任务调度有什么区别？
- 轮询调度的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。只有在当前任务主动放弃CPU控制权的情况下（比如任务挂起），才允许其他任务（包括高优先级的任务）控制CPU。开始循环。
- 抢占式调度允许高优先级的任务打断当前执行的任务，抢占CPU的控制权。这有利于后面的高优先级的任务也能及时得到响应。但实现相对较复杂且可能出现低优先级的任务长期得不到调度。
