# 壹——JAVA知识
## 一、JAVA基础

## 二、异常



## 三、集合





## 四、多线程
### 1、线程池的实现？四种线程池？重要参数及原理？
- 一．Executors： 提供了一系列工厂方法用于创先线程池，返回的线程池都实现了ExecutorService 接口。
  - ThreadPoolExecutor：线程池的具体实现类,一般用的各种线程池都是基于这个类实现的。
  - 设置核心池的数量为 CPU 数的两倍，一般是 4、8，好点的 16 个线程
  - 最大线程数设置为 64
  - 空闲线程的存活时间设置为 1 秒
- 二．corePoolSize：线程池的核心线程数
	- 线程池中运行的线程数也永远不会超过corePoolSize 个,默认情况下可以一直存活。可以通过设置allowCoreThreadTimeOut为True,此时 核心线程数就是0,此时keepAliveTime控制所有线程的超时时间。
  - maximumPoolSize：线程池允许的最大线程数;
  - keepAliveTime： 指的是空闲线程结束的超时时间;
  - unit ：是一个枚举，表示 keepAliveTime 的单位;
  - workQueue：表示存放任务的BlockingQueue<Runnable队列。
  - BlockingQueue:阻塞队列（BlockingQueue）是java.util.concurrent下的主要用来控制线程同步的工具。如果BlockQueue是空的,从BlockingQueue取东西的操作将会被阻断进入等待状态,直到BlockingQueue进了东西才会被唤醒。同样,如果BlockingQueue是满的,任何试图往里存东西的操作也会被阻断进入等待状态,直到BlockingQueue里有空间才会被唤醒继续操作。
  - 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。具体的实现类有LinkedBlockingQueue,ArrayBlockingQueued等。一般其内部的都是通过Lock和Condition(显示锁（Lock）及Condition的学习与使用)来实现阻塞和唤醒。
  - threadFactory：每个线程创建的地方 ，可以给线程起个好听的名字，设置个优先级啥的
  - andler：饱和策略，大家都很忙，咋办呢，有四种策略 
    - CallerRunsPolicy：只要线程池没关闭，就直接用调用者所在线程来运行任务
    - AbortPolicy：直接抛出 RejectedExecutionException 异常
    - DiscardPolicy：悄悄把任务放生，不做了
    - DiscardOldestPolicy：把队列里待最久的那个任务扔了，然后再调用 execute() 试试看能行不
  - 我们也可以实现自己的 RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的
- 三．四种线程池
	- 1.newFixedThreadPool
		- 不招外包，有固定数量核心成员的正常互联网团队。
		- 可以看到，FixedThreadPool 的核心线程数和最大线程数都是指定值，也就是说当线程池中的线程数超过核心线程数后，任务都会被放到阻塞队列中。
		- 此外 keepAliveTime 为 0，也就是多余的空余线程会被立即终止（由于这里没有多余线程，这个参数也没什么意义了）。
		- 而这里选用的阻塞队列是 LinkedBlockingQueue，使用的是默认容量 Integer.MAX_VALUE，相当于没有上限。
		- 因此这个线程池执行任务的流程如下：
			- 线程数少于核心线程数，也就是设置的线程数时，新建线程执行任务
			- 线程数等于核心线程数后，将任务加入阻塞队列 
			- 由于队列容量非常大，可以一直加加加
			- 执行完任务的线程反复去队列中取任务执行
		- FixedThreadPool 用于负载比较重的服务器，为了资源的合理利用，需要限制当前线程数量。
- 2.newSingleThreadExecutor
	- 不招外包，只有一个核心成员的创业团队。
	- 从参数可以看出来，SingleThreadExecutor 相当于特殊的 FixedThreadPool，它的执行流程如下：
		- 线程池中没有线程时，新建一个线程执行任务
		- 有一个线程以后，将任务加入阻塞队列，不停加加加
		- 唯一的这一个线程不停地去队列里取任务执行
	- 听起来很可怜的样子 - -。
	- SingleThreadExecutor 用于串行执行任务的场景，每个任务必须按顺序执行，不需要并发执行。
- 3.newCachedThreadPool
	- 全部外包，没活最多待 60 秒的外包团队。
	- 可以看到，CachedThreadPool 没有核心线程，非核心线程数无上限，也就是全部使用外包，但是每个外包空闲的时间只有 60 秒，超过后就会被回收。
	- CachedThreadPool 使用的队列是 SynchronousQueue，这个队列的作用就是传递任务，并不会保存。
	- 因此当提交任务的速度大于处理任务的速度时，每次提交一个任务，就会创建一个线程。极端情况下会创建过多的线程，耗尽 CPU 和内存资源。
	- 它的执行流程如下：
		- 没有核心线程，直接向 SynchronousQueue 中提交任务
		- 如果有空闲线程，就去取出任务执行；如果没有空闲线程，就新建一个
		- 执行完任务的线程有 60 秒生存时间，如果在这个时间内可以接到新任务，就可以继续活下去，否则就拜拜
	- 由于空闲 60 秒的线程会被终止，长时间保持空闲的 CachedThreadPool 不会占用任何资源。
	- CachedThreadPool 用于并发执行大量短期的小任务，或者是负载较轻的服务器。
- 4.newScheduledThreadPool
	- 定期维护的 2B 业务团队，核心与外包成员都有。
	- ScheduledThreadPoolExecutor 继承自 ThreadPoolExecutor， 最多线程数为 Integer.MAX_VALUE ，使用 DelayedWorkQueue 作为任务队列。
	- ScheduledThreadPoolExecutor 添加任务和执行任务的机制与ThreadPoolExecutor 有所不同。
	- ScheduledThreadPoolExecutor 添加任务提供了另外两个方法：
		- scheduleAtFixedRate() ：按某种速率周期执行
		- scheduleWithFixedDelay()：在某个延迟后执行

- 四。保存待执行任务的阻塞队列
	- 当线程池中的核心线程数已满时，任务就要保存到队列中了。
	- 线程池中使用的队列是 BlockingQueue 接口，常用的实现有如下几种：
		- rayBlockingQueue：基于数组、有界，按 FIFO（先进先出）原则对元素进行排序
		- LinkedBlockingQueue：基于链表，按FIFO （先进先出） 排序元素 
		- 吞吐量通常要高于 ArrayBlockingQueue
		- Executors.newFixedThreadPool() 使用了这个队列
		- SynchronousQueue：不存储元素的阻塞队列 
		- 每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态
		- 吞吐量通常要高于 LinkedBlockingQueue
		- Executors.newCachedThreadPool使用了这个队列
		- PriorityBlockingQueue：具有优先级的、无限阻塞队列           

- 五.任务拒绝策略
  - 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略：
  - 1.ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
  - 2.ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。
  - 3.ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
  - 4.ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务  
- 六.线程池的关闭
  - readPoolExecutor提供了两个方法，用于线程池的关闭。、
  	- shutdownNow方法的解释是：线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。
  	- shutdown方法的解释是：线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。

## 五、JAVA虚拟机

## 六、内部类


## 七、代码分析



# 贰——设计模式




# 叁——计算机网络



# 肆——Web



# 伍——框架
### 1、Spring框架的好处，为什么使用它？
* 我们是在使用Spring框架的过程中，其实就是为了使用IOC（依赖注入）和AOP（面向切面编程），这两个是Spring的灵魂。
* 方便解耦，简化开发
  * Spring就是一个大工厂，可以将所有对象创建和依赖关系维护，交给Spring管理
* AOP编程的支持
  * Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能
* 声明式事务的支持
  * 只需要通过配置就可以完成对事务的管理，而无需手动编程
* 方便程序的测试
  * Spring对Junit4支持，可以通过注解方便的测试Spring程序
* 方便集成各种优秀框架
  * Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts2、Hibernate、MyBatis、Quartz等）的直接支持
* 降低JavaEE API的使用难度
  * Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低
* Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部 
* Spring的DI机制降低了业务对象替换的复杂性

### 2、解释一下IOC、DI和AOP

- spring的IOC容器是spring的核心，spring AOP是spring框架的重要组成部分。
- **控制反转（IOC）**：控制反转也叫依赖注入。利用了工厂模式
  - 在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此**控制反转（IOC）**，创建被调用者实例的工作通常由spring容器来完成；然后注入调用者，因此也被称为**依赖注入（DI）**，依赖注入和控制反转是同一个概念。
  - Spring以动态灵活的方式来管理对象 ， 注入的两种方式，**设置注入**和**构造注入**。 
  	- 设置注入的优点：直观，自然 
  	- 构造注入的优点：可以在构造器中决定依赖关系的顺序。 
  - 将对象交给容器管理，你只需要在spring配置文件中配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来**注入**，而不需要你在A里面new这些bean了。
  ```java
  <bean id="student" class="com.edu.bean.Student">
      <property name="name" value="小红"></property>
      <property name="gender" value="女"></property>
  </bean>
  
  //1、创建ioc容器对象：
  ApplicationContext applicationContext = new ClassPathXmlApplicationContext("spring.xml");
  
  //2、从容器中获得维护的Student实例
  
  //2.1通过id
  Student student1 = (Student)applicationContext.getBean("student");
  //2.2通过类名
  Student student2 = applicationContext.getBean(Student.class);
  ```
- **面向切面编程（AOP)**（Aspect-Oriented Programming）：AOP就是典型的代理模式的体现。

  - OOP将应用程序分解成**各个层次的对象**，而AOP将程序**分解成多个切面**。springAOP 只实现了方法级别的连接点，在J2EE应用中，AOP拦截到方法级别的操作就已经足够。
  - 面向切面编程（AOP)是以另一个角度来考虑程序结构，通过分析程序结构的关注点来完善面向对象编程（OOP）。**AOP可以说是对OOP的补充和完善**。
  - OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。将程序中的交叉业务逻辑（比如安全，日志，事务等），**封装成一个切面，然后注入到目标对象**（具体业务逻辑）中去。
  - 实现AOP的技术，主要分为两大类：
    - 一是采用**动态代理技术**，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；
    - 二是采用**静态织入**的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码.
  - 面向切面编程（AOP）完善spring的依赖注入（DI），面向切面编程在spring中主要表现为两个方面 
  	- 面向切面编程提供声明式事务管理 
  	- spring支持用户自定义的切面 
  - aop框架具有的两个特征： 
  	- 各个步骤之间的良好隔离性 
  	- 源代码无关性 



### 3、Spring中用到的设模式
- 主要用到的设计模式有**工厂模式**和**代理模式**。
  - IOC就是典型的工厂模式，通过sessionfactory去注入实例。
  - AOP就是典型的代理模式的体现。
  	- 代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。
- spring中用到的九种设计模式(http://itxxz.com/a/javashili/tuozhan/2014/0601/7.html)
  - 第一种：简单工厂
    - 又叫做静态工厂方法（StaticFactory Method）模式，但不属于23种GOF设计模式之一。 
    - 简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。 
    - spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。
  - 第二种：工厂方法（Factory Method）
    -  通常由应用程序直接使用new创建新的对象，为了将对象的创建和使用相分离，采用工厂模式,即应用程序将对象的创建及初始化职责交给工厂对象。
    -  一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。
  - 第三种：单例模式（Singleton）
    - 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 
    - Spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。 
    - 核心提示点：Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定
  - 第四种：适配器（Adapter）
    - 在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。
    - Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，**生成被代理类的代理类**， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。
      ```java
      Adapter类接口：Target
      public interface AdvisorAdapter {
          boolean supportsAdvice(Advice advice);
          MethodInterceptor getInterceptor(Advisor advisor);
      }
      MethodBeforeAdviceAdapter类，Adapter
      class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {
          public boolean supportsAdvice(Advice advice) {
              return (advice instanceof MethodBeforeAdvice);
          }
          public MethodInterceptor getInterceptor(Advisor advisor) {
              MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();
              return new MethodBeforeAdviceInterceptor(advice);
          }
      }
      ```
  - 第五种：包装器（Decorator）
    - 在我们的项目中遇到这样一个问题：我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。我们以往在spring和hibernate框架中总是配置一个数据源，因而sessionFactory的dataSource属性总是指向这个数据源并且恒定不变，所有DAO在使用sessionFactory的时候都是通过这个数据源访问数据库。但是现在，由于项目的需要，我们的DAO在访问sessionFactory的时候都不得不在多个数据源中不断切换，问题就出现了：如何让sessionFactory在执行数据持久化的时候，根据客户的需求能够动态切换不同的数据源？我们能不能在spring的框架下通过少量修改得到解决？是否有什么设计模式可以利用呢？ 
    - 首先想到在spring的applicationContext中配置所有的dataSource。这些dataSource可能是各种不同类型的，比如不同的数据库：Oracle、SQL Server、MySQL等，也可能是不同的数据源：比如apache 提供的org.apache.commons.dbcp.BasicDataSource、spring提供的org.springframework.jndi.JndiObjectFactoryBean等。然后sessionFactory根据客户的每次请求，将dataSource属性设置成不同的数据源，以到达切换数据源的目的。
    - spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。 
  - 第六种：代理（Proxy）
    - 为其他对象提供一种代理以控制对这个对象的访问。 
    - 从结构上来看和Decorator模式类似，但Proxy是控制，更像是一种对功能的限制，而Decorator是增加职责。 
    - spring的Proxy模式在aop中有体现，比如JdkDynamicAopProxy和Cglib2AopProxy。 
  - 第七种：观察者（Observer）
    - 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
    - spring中Observer模式常用的地方是listener的实现。如ApplicationListener。
  - 第八种：策略（Strategy）
    - 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。 
    - spring中在实例化对象的时候用到Strategy模式
  - 第九种：模板方法（Template Method）
    - 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
    - Template Method模式一般是需要继承的。这里想要探讨另一种对Template Method的理解。
    - spring中的JdbcTemplate，在用这个类时并不想去继承这个类，因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？那我们就用**回调对象**吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。这可能是Template Method不需要继承的另一种实现方式吧。 

### 4、spring原理 
- 内部最核心的就是IOC了，动态注入，让一个对象的创建不用new了，可以自动的生产，这其实就是利用java里的反射，反射其实就是在运行时动态的去创建、调用对象，Spring就是在运行时，跟xml Spring的配置文件来动态的创建对象，和调用对象里的方法的 。  
- Spring还有一个核心就是AOP这个就是面向切面编程，可以为某一类对象 进行监督和控制（也就是 在调用这类对象的具体方法的前后去调用你指定的 模块）从而达到对一个模块扩充的功能。这些都是通过  配置类达到的。  
- Spring目的：就是让对象与对象（模块与模块）之间的关系没有通过代码来关联，都是通过配置类说明管理的（Spring根据这些配置 内部通过反射去动态的组装对象）  
- 要记住：Spring是一个容器，凡是在容器里的对象才会有Spring所提供的这些服务和功能。  
- Spring里用的最经典的一个设计模式就是：模板方法模式。(这里我都不介绍了，是一个很常用的设计模式)， Spring里的配置是很多的，很难都记住，但是Spring里的精华也无非就是以上的两点，把以上两点跟理解了 也就基本上掌握了Spring.
- Spring AOP与IOC
	- IoC(Inversion of control): 控制反转    
		- 概念：控制权由对象本身转向容器；由容器根据配置文件去创建实例并创建各个实例之间的依赖关系  		- 核心：bean工厂；在Spring中，bean工厂创建的各个实例称作bean  
	- AOP(Aspect-Oriented Programming): 面向方面编程  
		- 代理的两种方式：  
			- 静态代理：  
				- 针对每个具体类分别编写代理类；  
				- 针对一个接口编写一个代理类；  
			- 动态代理：  
				- 针对一个方面编写一个InvocationHandler，然后借用JDK反射包中的Proxy类为各种接口动态生成相应的代理类

# 陆——数据库
### 1、根据以表格，以学号为主键，在数据库中创建表student
```sql
create table STUDENT{
  STU_NO char(20) NOT NULL PRIMARY KEY,
  STU_NAME char(20),
  STU_SEX char(1) default NULL,
  STU_AGE int,
  STU_SERI char(20)
}
```

### 2、MySQL左右连接，全连接
- 1）inner join（内连接），在两张表进行连接查询时，只保留两张表中完全匹配的结果集。
  ```sql
  select a.*,b.* from a inner join b on a.id=b.parent_id   
  ```
- 2）left join（左连接）,在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。我们使用left join对两张表进行连接

  ```sql
  select a.*,b.* from a left join b on a.id=b.parent_id
  ```
- 3）right join（右连接）,在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。

  ```sql
  select a.*,b.* from a right join b on a.id=b.parent_id   
  ```
- 4）full join（全连接）,在两张表进行连接查询时，返回左表和右表中所有没有匹配的行。

  ```sql
  select a.*,b.* from a full join b on a.id=b.parent_id
  ```

### 3、数据库四大特性
- 数据库四大特性（ACID）
	- 1.原子性（Atomicity）
	- 2.一致性（Consistency）
	- 3.隔离性（Isolation）
	- 4.持久性（Durability）
- 1.原子性（Atomicity）

  - 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。失败回滚的操作事务，将不能对事物有任何影响。
- 2.一致性（Consistency）
	- 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
	- 数据库状态如何变化？每一次数据变更就会导致数据库的状态迁移。如果数据库的初始状态是C0，第一次事务T1的提交就会导致系统生成一个SYSTEM CHANGE NUMBER（SCN），这是数据库状态从C0转变成C1。执行第二个事务T2的时候数据库状态从T1变成T2，以此类推，执行第Tn次事务的时候数据库状态由C(n-1)变成Cn。
	- 一致性可以从一致读和一致写两个方面来理解。、
	- 一致读 事务读取数据只能从一个状态中读取，不能从2个或者2个以上状态读取。也就是T(n)只能从C(n-1），C(n-2)... C(1)中的一个状态读取数据，不能一部分数据读取自C(n-1)，而另一部分数据读取自C(n-2)。
	- 一致写 事务执行的数据变更只能基于上一个一致的状态，且只能体现在一个状态中。T(n)的变更结果只能基于C(n-1)，C(n-2), ...C(1)状态，且只能体现在C(n)状态中。也就是说，一个状态只能有一个事务变更数据，不允许有2个或者2个以上事务在一个状态中变更数据。至于具体一致写基于哪个状态，需要判断T(n)事务是否和T(n-1)，T(n-2),...T(1)有依赖关系。
- 3.隔离性（Isolation）
	- 隔离性是指当多个用户并发访问数据库时，比如同时访问一张表，数据库每一个用户开启的事务，不能被其他事务所做的操作干扰，多个并发事务之间，应当相互隔离。
	- 例如同时有T1和T2两个并发事务，从T1角度来看，T2要不在T1执行之前就已经结束，要么在T1执行完成后才开始。将多个事务隔离开，每个事务都不能访问到其他事务操作过程中的状态。
	- 关于事务的隔离性，数据库也提供了多种方案，后面我们将会进行详细介绍
- 4.持久性（Durability）

  - 持久性是指事务的操作，一旦提交，对于数据库中数据的改变是永久性的，即使数据库发生故障也不能丢失已提交事务所完成的改变。

- 在了解完数据库的四大特性之后，我们来讨论一下数据库的隔离级别的问题。在此之前，我们考虑在没有数据库隔离性的情况下，多用户并发操作可能会发生的问题。
  - 1.脏读（写、读、写（回滚））

    - 脏读是指一个事务读取了未提交事务执行过程中的数据。
    - 当一个事务的操作正在多次修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据。
    - 最典型的例子就是银行转账，从A账户转账100到B账户，脚本命令为
          ```sql
          update account set money = money + 100 where username = 'B';
          update account set money = money - 100 where username = 'A';
          ```
    - 在这个事务执行过程中，另外一个事务读取结果发现B账户中的钱已经到账，提示B钱已到账，B就进行了下一步的操作。但是最终转账事务失败，导致操作回滚。实际上B并未收到钱，但是进行了下一步的操作，造成了损失，这就是脏读。
  - 2.不可重复读（读、写、读）

    - 不可重复读是指对于数据库中的某个数据，一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了。
    - 不可重复读同脏读的区别在于，脏读是一个事务读取了另一未完成的事务执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。
  - 3.虚读(幻读)（写（多数）、写（一个）、读）

    - 幻读是事务非独立执行时发生的一种现象，例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有进行修改，而这条数据其实是T2刚刚提交插入的，这就是幻读。
    - 幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。

### 4、事务的四大隔离级别?

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读   |
| :---------- | :--- | :--------- | :------------- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 读已提交（read-committed）   | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

- 01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。
- 02：Read Committed(读已提交)：可避免脏读的发生。
- 03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。
- 04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。 

### 5、数据库的锁
- 锁机制
	- 共享锁
		- 由读表操作加上的锁，加锁后其他用户只能获取该表或行的共享锁，不能获取排它锁，也就是说只能读不能写
	- 排它锁
		- 由写表操作加上的锁，加锁后其他用户不能获取该表或行的任何锁，典型是mysql事务
- 根据锁的范围，可以分为
	- 表锁
		- 给整张表加锁
	- 行锁
		- 给行数据加锁
- 因此锁可以分为表级共享锁、行级共享锁、表级排它锁、行级排它锁。

### 6、应该在什么字段上建立索引?
- **主键、外键、连接字段、where后的字段**
- 1、表的主键、外键必须有索引； 
- 2、数据量超过300的表应该有索引； 
- 3、经常与其他表进行连接的表，在连接字段上应该建立索引； 
- 4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； 
- 5、索引应该建在选择性高的字段上； 
- 6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； 
- 7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
	- A、正确选择复合索引中的主列字段，一般是选择性较好的字段；
	- B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
	- C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
	- D、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
- 8、频繁进行数据操作的表，不要建立太多的索引； 
- 9、删除无用的索引，避免对执行计划造成负面影响；

### 7、mysql索引的用途：
- 保持数据的完整性；
- 优化数据的访问性能
- 改进表的链接（join）操作
- 对结果进行排序
- 简化聚合数据操作

### 8、索引的数据结构
- 索引的数据结构：B-、B+、R-、散列
- 散列实现对直接查找方式能提供最优的性能，但对一定范围的查找却效率底下。
- B-树索引实现是一个专门为范围查询设计的。
- B-树：
  - B-树结构支持插入、控制操作以及通过管理一系列树根状结构的彼此联通的节点中来做选择。B-树结构中有两种节点类型：索引节点和叶子节点。叶子节点是存储数据的，而索引节点是用来告诉用户存储在叶子节点中的数据的顺序，并帮助用户找到数据。B-树不是二叉树，二叉树只是一种简单的节点层次结构的实现。
- B+树
  - B+树是B-树结构的增强版，尽管B+树支持B-树的所有特性，他们之间最显著的不同点在于B+树中底层数据是按照提及的索引列进行排序的。B+树还通过在叶子节点之间附加引用来优化扫描的性能。
- 散列
  - 散列表数据结构是一个简单的概念，他将一种算法应用到给定值中以在底层数据存储系统中返回一个唯一的指针或位置。散列表的优点是始终以线性时间复杂度找到需要读取的行的位置，而不想B-树那样需要跨越多层节点来确定位置。
- 通信R-树
  - R-树数据结构支持基于数据类型对集合数据进行管理。目前只有MyIsam使用R-树支持空间索引。使用空间索引也有很多限制，比如只支持唯一的NOT NULL 列等。空间索引并不常用。


### 9、覆盖索引
- **如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为“覆盖索引”**。
- 一、覆盖索引的优点
	- 覆盖索引是非常有用的工具，能够极大的提高性能。如果查询只需要扫描索引而无需回表，会带来多少好处：
	- 索引条目通常远小于数据行大小，所以如果只需读取索引，那mysql就会极大的减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也很有帮助，因为索引比数据更小，更容易全部放入内存中。
	- 因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少的多。对于某些存储引擎，例如MyISAM，甚至可以通过optimize命令使得索引完全顺序排列，这让简单的范围查询能使用完全顺序的索引访问。
	- 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占用了数据访问中的最大开销的场景。
	- 由于InnoDB的聚簇索引，覆盖索引对InnoDB特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。
- 二、覆盖索引的适用范围
	- 不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以mysql只能使用B-Tree索引做覆盖索引。另外，不同的存储引擎实现覆盖索引的方式也不同，而且不是所有的引擎都支持覆盖索引。
- 三、有关覆盖索引的优化问题
	- 当发起一个被索引覆盖的查询时，在EXPLAIN的extra列可以看到“Using index”的信息。索引覆盖查询还有很多陷阱可能会导致无法实现优化。MySQL查询优化器会在执行查询前判断是否有一个索引能进行覆盖。假设索引覆盖了where条件中的字段，但不是整个查询涉及的字段。如果条件为假，MySQL5.5或更早的版本也总是会回表获取数据行，尽管并不需要这一行且最终会被过滤掉。
	- 为什么会发生这样的情况，以及如何重写查询以解决该问题？这里索引无法覆盖该查询，有两个原因：
		- 没有任何索引能够覆盖这个查询。因为查询从表中选择了所有的列，而没有任何索引覆盖了所有的列。不过，理论上MySQL还有一个捷径可以利用：where条件中的列是有索引可以覆盖的，因此MySQL可以使用该索引找到对应的索引列数据并检查索引列上列数据是否匹配，过滤之后再读取需要的数据行。
		- MySQL不能在索引中执行like操作。这是底层存储引擎API的限制，MySQL5.5和更早的版本中只允许在索引中做简单比较操作（例如等于、不等于以及大于）。MySQL能在索引中做最左前缀匹配的like比较，因为该操作可以转换为简单的比较操作，但是如果是通配符开头的like查询，存储引擎就无法做比较匹配。这种情况下，MySQL服务器只能提取数据行的值而不是索引值来做比较。
	- 其实也有办法解决上面所说的两个问题，需要重写查询并巧妙的设计索引。看下面的例子：
		- 1、首先将索引扩展至覆盖三个数据列（actor、title、prod_id)
		- 2、然后按照如下方式重写查询:`select * from products join (select prod_id from products where actor='sean_carrey' and title like '%apollo%' ) as t1 on (t1.prod_id = products.prod_id)`;
		- 这种方式叫做延迟关联，因为延迟了队列的访问。在查询的第一阶段MySQL可以使用覆盖索引，在from子句的子句中找到匹配的prod_id，然后根据这些prod_id值在外层查询匹配所需要的所有列值。虽然无法使用覆盖索引覆盖整个查询，但总算比完全无法利用覆盖索引的好。
		- 在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以更进一步优化InnoDB。回想一下，InnoDB的二级索引的叶子节点包含了主键的值，这意味着InnoDB的二级索引可以有效的利用这些“额外”的主键列来覆盖查询。

### 10、分布式锁有哪些？怎么实现？
- 分布式锁
  - 基于数据库的锁
  - 基于缓存的锁（Redis、Memcached）
  - 基于分布式算法的锁（Zookeeper）
- 使用Zookeeper实现：

  - 此种方式不太常用，性能也比较低，但理论上也是最安全的，可以使用Curator框架实现，使用其中InterProcessMutex类可以非常方便的实现分布式锁
- 使用Redis实现：
  - 这种方式最为常见，具体步骤如下：
    - 1、方法开始执行时，通过如下命令，向Redis获取一个锁
          ```sql
          SET resource_name my_random_value NX PX 30000
          ```

      - NX表示，只有当resource_name对应的key不存在时，才能SET成功，这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。
      - PX 30000 是一个自动过期时间，客户端可以根据自己的业务常见，选择合适的过期时间。
      - 上面的命令如果执行成功，则客户端成功获取到了锁；而如果上面的命令执行失败，则说明获取锁失败。
    - 2、方法执行完毕后，可以通过如下lua脚本删除锁
      ```
      local v = redis.call('GET', KEYS[1]);
      local r= 0;
      if v == ARGV[1] then
      	r =redis.call('DEL',KEYS[1]);
      end
      return r
      ```
	- 使用上面Redis实现，有如下几个问题：
		- 1、必须设置超时时间，假如没有设置超时时间，当一个程序获取到锁后，他崩溃了，或者因为网络问题，导致它再也无法和Redis通讯了，那么它会一直持有这个锁，而其他的客户端永远无法获取到这个锁
		- 2、这个my_random_value是很有必要的，它保证了一个客户端释放的锁，一定是自己的
		- 2、加锁的过程，依然不支持可重入性，如果想实现可重入性，可以将 MAC地址 + jvm进程ID + 线程ID 作为my_random_value设置进缓存
		- 3、依然是单点的，当redis挂掉，会导致服务不可用，假如给这个Redis挂一个Slave，但由于Redis的服务是异步的，会丧失锁的安全性
		- 4、释放锁的过程使用lua脚本，是为了保证原子性，网上有人将加锁过程分为两步执行，先使用SETNX命令加锁，再使用PEXPIRE命令设置锁的超时时间，将这两步放在lua脚本中，也是为了保证原子性
		- 5、超时时间应该设置成多少呢？假如方法执行时间过长，超过了设置的超时时间，当Redis已经自动删除的key，而方法依然在执行，这可能会导致程序出现发生不一致性，出现严重BUG，这看起来是个两难的问题




# 柒——数据结构

### 1、最短路径算法
- 最短路径—Dijkstra算法和Floyd算法
- Dijkstra算法
	- 算法基本思想：
		- 每次新扩展一个距离最短的点,更新与其相邻点间距离。当所有边的权都为正时,由于不会存在一个距离更短的没有扩展过的点,所以这个点的距离不会再被改变,因而保证了算法的正确性。根据这个原理,采用Dijkstra算法求解最短路的图不能有负权边,因为扩展到负权边的时候会产生更短的距离,有可能破坏已经更新的点距离不会改变的性质。
- 弗洛伊德算法：
	- 算法思想原理：
		- Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）
		- 从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。
	- 算法描述：
		- a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　
		- b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。

### 2、图的存储结构
- 一般存储图的方式有两种：
	- 一是用邻接矩阵表示，
	- 二是用邻接链表。
- 所谓用邻接矩阵，是用一个二维数组存储，边使用矩阵来构建模型，这使得每一个顶点和其它顶点之间都有边的有无 的 表示的机会。若有边，则他们交点 为1 ，否则为0。当然，如果是一副边有权值的图，交点存储的是他们边的权值。

### 3、冒泡排序原理及优化
- 冒泡排序原理
  - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
  - 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
  - 针对所有的元素重复以上的步骤，除了最后一个。
  - 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
- 优化
  - 关于冒泡排序的优化，主要针对的是其交换的场合，如果说输入的数几乎是有序的，在排序的过程中其已经有序了，就让其循环提前终止，这是第一种思路。
  - 还有一种优化方法，不发生交换即表明符合有序条件，假如有序区间的边界和最后一次发生交换的位置之间也是有序的，所以可以一下子扩大有序区间，提高效率。（给一个标志位，当每一次调换完之后，这个标志位如果没变的话，则说明前面的数据是有序的，如果改变的话说明是无序的。）

# 捌——算法






# 玖——逻辑



# 拾——操作系统

### 1、linux中的grep管道用处？linux的常用命令？
- 功能说明：查找文件里符合条件的字符串。
- Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
- grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。
