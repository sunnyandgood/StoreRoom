# [两数之和](https://leetcode-cn.com/problems/two-sum/description/)

## 题目

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。<br/>

  >示例:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给定 nums = [2, 7, 11, 15], target = 9 <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 nums[0] + nums[1] = 2 + 7 = 9<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以返回 [0, 1]

## 解答

### 方法一：暴力法

* 题目分析

    * 遍历每个元素x，并查找是否存在`arr[x] + arr[x+1] = target;` 的目标元素。

* 代码

      class Solution {
          public int[] twoSum(int[] nums, int target) {
              int[] arr = new int[2];
              for(int i=0;i<nums.length;i++){
                  for(int j=i+1;j<nums.length;j++){
                      if(nums[i]+nums[j]==target){
                          arr[0] = i;
                          arr[1] = j;
                          break;
                      }
                  }
              }
              return arr;
          }
      }

* 复杂度分析：

    * 时间复杂度：O(n²)， 对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n²)。

    * 空间复杂度：O(1)。 


### 方法二：两遍哈希表


* 题目分析

    * 通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 **近似** 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。
    * 一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！























